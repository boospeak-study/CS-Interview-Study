## 문제 1

**유형**: OX형

**문제**: DB는 데이터 내용이 아닌 데이터 레코드의 주소나 위치를 이용하여 데이터를 참조한다.

<details>
<summary>정답 확인하기</summary>

**정답**: X

**해설**: 데이터베이스에 있는 데이터를 참조할 때, 데이터 레코드의 주소나 위치가 아닌 사용자가 요구하는 데이터의 내용으로 데이터를 찾는다. 이러한 데이터베이스의 특징을 '내용에 의한 참조(Content Reference)'라고 한다.

**참고 자료**: [TTA정보통신용어사전](http://terms.tta.or.kr/mobile/dictionaryView.do?subject=%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4)

</details>

---

## 문제 2

**유형**: OX형

**문제**: SQL Injection 공격은 주로 DB의 읽기 작업에만 영향을 미치며, DB의 내용을 변경하는 것은 불가능하다.

<details>
<summary>정답 확인하기</summary>

**정답**: X

**해설**: SQL Injection 공격의 본질은 웹 앱의 입력값 검증이 제대로 이루어지지 않아서, 악의적인 SQL 쿼리를 삽입하여 DB를 조작하는 것이다. 따라서 SELECT 뿐만 아니라 INERT, UPDATE, DELETE 등에 대해서도 Injection이 가능하다.

**참고 자료**: [Basic SQL injection | 엄범](https://umbum.dev/352/)

</details>

---

## 문제 3

**유형**: OX형

**문제**: DB 정규화란 하나의 릴레이션에 하나의 의미만 존재하도록 릴레이션을 분해하는 과정이다.

<details>
<summary>정답 확인하기</summary>

**정답**: O

**해설**: 정규화를 통해 하나의 릴레이션에 하나의 의미만 존재하도록 릴레이션을 분해해간다. 이는 데이터의 일관성, 최소한의 데이터 중복, 최대한의 데이터 유연성을 위함이다.

또한 정규화는 불필요한 데이터를 제거해서 불필요한 중복을 최소화하고, 삽입/갱신/삭제 시 발생하는 [이상 현상(Anomaly)](https://dev-coco.tistory.com/63)를 방지한다.

**참고 자료**: [Basic SQL injection | 엄범](https://umbum.dev/352/)

</details>

---

## 문제 4

**유형**: 객관식

**문제**:

| 학번    | 이름   | 학과         | 이메일                                                                                    | 전화번호      |
| ------- | ------ | ------------ | ----------------------------------------------------------------------------------------- | ------------- |
| 2023001 | 김철수 | 컴퓨터공학과 | [chulsoo@example.com](https://www.google.com/url?sa=E&q=mailto%3Achulsoo%40example.com)   | 010-1234-5678 |
| 2023002 | 이영희 | 전자공학과   | [younghee@example.com](https://www.google.com/url?sa=E&q=mailto%3Ayounghee%40example.com) | 010-9876-5432 |
| 2024001 | 박민수 | 컴퓨터공학과 | [minsoo@example.com](https://www.google.com/url?sa=E&q=mailto%3Aminsoo%40example.com)     | 010-1111-2222 |
| 2024002 | 김철수 | 산업공학과   | [chulsoo2@example.com](https://www.google.com/url?sa=E&q=mailto%3Achulsoo2%40example.com) | 010-3333-4444 |
| 2025001 | 최지혜 | 화학공학과   | [jihye@example.com](https://www.google.com/url?sa=E&q=mailto%3Ajihye%40example.com)       | 010-5555-6666 |

위의 테이블에서 후보키(Candidate Key)가 될 수 있는 속성 또는 속성 집합을 모두 고르시오.

**보기**: 

1. 학번
2. 이메일
3. {학과, 이메일}
4. 전화번호
5. {학번, 이름}

<details>
<summary>정답 확인하기</summary>

**정답**: 1

**해설**: 후보키(Candidate Key)는 기본키(Primary Key)가 될 수 있는 후보를 말한다. 후보키는 '유일성'과 '최소성'의 조건을 만족해야 한다.
유일성: Key로 하나의 Tuple을 유일하게 식별할 수 있어야한다.
최소성: 꼭 필요한 속성으로만 구성되어야 한다.
속성 중 학생을 유일하게 식별할 수 있는 것은 학번이다. 따라서 1번이 해당되고 5번의 경우 학번 이외에 이름이 포함된 집합으로 꼭 필요한 속성이 아니기 때문에 최소성에 어긋난다.

**참고 자료**: [Key | 👨🏻‍💻 Tech Interview](https://gyoogle.dev/blog/computer-science/data-base/Key.html)

</details>

---

## 문제 5

**유형**: 객관식

**문제**: 다음 테이블을 사용할 경우 발생하는 이상 현상(anomaly)으로 올바른 것을 모두 고르시오.


| 학번 | 이름   | 학과       | 학과전화번호 | 수강과목     | 성적 |
| ---- | ------ | ---------- | ------------ | ------------ | ---- |
| 1001 | 김철수 | 컴퓨터공학 | 02-1234-5678 | 데이터베이스 | A    |
| 1001 | 김철수 | 컴퓨터공학 | 02-1234-5678 | 자료구조     | B    |
| 1002 | 이영희 | 경영학     | 02-9876-5432 | 회계원리     | A    |

**보기**: 

1. 김철수의 학과 정보가 변경될 경우 여러 레코드를 수정해야 한다.
2. 학생마다 고유한 학번이 부여되어 있어 중복 데이터가 발생하지 않는다.
3. 아직 수강 과목이 없는 신입생 정보는 저장할 수 없다.
4. 이영희가 유일하게 수강한 과목을 취소하면 이영희의 모든 정보가 삭제된다.
5. 학과 정보를 변경할 시 수강 과목과 성적도 변경이 일어난다.

<details>
<summary>정답 확인하기</summary>

**정답**: 1, 3, 4

**해설**: 1번은 갱신 이상, 3번은 삽입 이상, 4번은 삭제 이상과 연관되어 있는 보기이다.
2번: 학생마다 고유한 학번을 가지고 있는 것과는 별개로, 학번은 중복되어 나타나고 있다.
5번: 학과 정보의 수정과 수강 과목, 성적은 연관성이 없다.

**참고 자료**: [Anomaly | 👨🏻‍💻 Tech Interview](https://gyoogle.dev/blog/computer-science/data-base/Anomaly.html)

</details>

---

## 문제 6

**유형**: 객관식

**문제**: 트랜잭션의 특성에 대한 설명으로 올바른 것을 모두 고르시오.

**보기**: 

1. 작업이 모두 반영되던지 아니면 전혀 반영되지 않아야 한다.
2. 실행이 완료되면 언제나 일관성 있는 상태를 유지해야 한다.
3. 둘 이상 트랜잭션이 동시에 실행될 경우 서로의 연산에 끼어들 수 없다.
4. 완료된 결과는 영구적으로 반영되어야 한다.
5. 한 트랜잭션 내 연산들은 부분적으로 실행될 수 있다.

<details>
<summary>정답 확인하기</summary>

**정답**: 1,2,3,4

**해설**: 1,2,3,4는 각각 원자성, 일관성, 격리성, 지속성을 뜻한다. 5번은 원자성 속성에 위배된다.

**참고 자료**: [[데이터베이스] 트랜잭션의 ACID 성질 - 하나몬](https://hanamon.kr/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98%EC%9D%98-acid-%EC%84%B1%EC%A7%88/)

</details>

---

## 문제 7

**유형**: 객관식

**문제**: 다음 중, NoSQL 데이터베이스가 적합한 상황을 모두 고르시오.

**보기**:

1. 대규모 온라인 쇼핑몰에서 수백만 명의 사용자가 동시에 제품을 조회하고 검색하는 상황
2. 은행의 계좌 이체 시스템
3. SNS 플랫폼에서의 프로필, 게시물, 친구 관계 등의 데이터 관리
4. 사물인터넷 센서 데이터 수집 시스템
5. 기업 내 회계 시스템

<details>
<summary>정답 확인하기</summary>

**정답**: 1, 3, 4

**해설**:
NoSQL이 빠른 조회에 유리하고, 데이터 구조의 변경과 확장 대처에 유리한 상황에 적합하다. SQL를 사용하는 RDBMS의 경우는 트랜잭션과 같은 기능을 통해 일관성, 무결성이 중요한 시스템에 적합하다.

1: 빠른 조회 속도를 위해서 적합하다.
2: 강력한 트랜잭션이 필요하므로 적합하지 않다.
3: 비정형 데이터를 유연하게 저장하고, 요구사항에 따라 수직/수평 확장에 유연한 대처가 가능하여 적합하다.
4: 대용량 시계열 데이터를 바르게 쓰고 처리해야 하므로 적합하다.
5: 재무 데이터는 정확하고 일관성이 엄격히 지켜져야 하므로 적합하지 않다.

**참고 자료**: [SQL과 NOSQL의 차이 | 👨🏻‍💻 Tech Interview](https://gyoogle.dev/blog/computer-science/data-base/SQL%20&%20NOSQL.html)

</details>

---

## 문제 8

**유형**: 서술형

**문제**: 데이터베이스에서 인덱스(Index)에 대해 서술하세요.

<details>
<summary>정답 확인하기</summary>

**정답**:

> 인덱스의 개념, 왜 사용하는지, 단점은 무엇인지 포함되어있으면 베스트

Index란 테이블을 처음부터 끝까지 검색하는 방법인 FTS(Full Table Scan)과는 달리 인덱스를 검색하여 해당 자료의 테이블을 엑세스 하는 방법입니다.

인덱스는 항상 정렬된 상태를 유지하기 때문에 원하는 값을 검색하는데 빠르지만, 새로운 값을 추가하거나 삭제, 수정하는 경우에는 쿼리문 실행 속도가 느려집니다.

즉, 인덱스는 데이터의 저장 성능을 희생하고 그대신 데이터의 검색 속도를 높이는 기능이라 할 수 있습니다.

**참고 자료**: [신입 개발자 기술면접 질문 정리 - 데이터베이스](https://dev-coco.tistory.com/158) [[DB] Index - 개념, 장단점, B+ Tree](https://velog.io/@zioo/DB-Index-%EA%B0%9C%EB%85%90-%EC%9E%A5%EB%8B%A8%EC%A0%90-B-Tree)

</details>

---

## 문제 9

**유형**: 서술형

**문제**: DBMS가 Index를 어떤 자료구조로 관리하고 있는지 서술하세요.

<details>
<summary>정답 확인하기</summary>

**정답**:

> B+Tree에 대해서 설명할 수 있는지 묻고 있음, 다른 자료구조와 비교해서 왜 B+Tree가 사용되는지 까지 설명하면 베스트

Index는 주로 B+Tree 인덱스 자료구조를 사용합니다. 자식 노드가 2개 이상인 B-Tree를 개선시킨 자료구조이며, BTree 리프노드들을 LinkedList로 연결하여 순차 검색을 용이하게 합니다. 해시 테이블보다 나쁜 O(log2N)의 시간복잡도를 갖지만 일반적으로 사용되는 자료구조입니다.

해시 테이블은 컬럼의 값으로 생성된 해시를 기반으로 인덱스를 구현합니다. 시간복잡도가 O(1)이라 검색이 매우 빠르지만, 부등호(<,>)와 같은 연속적인 데이터를 위한 순차 검색이 불가능하기 때문에 사용에 적합하지 않습니다.

**참고 자료**: [신입 개발자 기술면접 질문 정리 - 데이터베이스](https://dev-coco.tistory.com/158) [[DB] Index - 개념, 장단점, B+ Tree](https://velog.io/@zioo/DB-Index-%EA%B0%9C%EB%85%90-%EC%9E%A5%EB%8B%A8%EC%A0%90-B-Tree)

</details>

---

## 문제 10

**유형**: 서술형

**문제**: 트랜잭션 고립 수준(Isolation Level)에 대해서 간략하게 서술하세요.

<details>
<summary>정답 확인하기</summary>

**정답**:

> 트랜잭션의 개념과 필요성에 대해 설명할 수 있음을 확인. 인덱스를 포함해서 고립 수준을 묻는 문제도 네부캠 cs 문제에 포함되어 있었음.

트랜잭션 고립 수준은 트랜잭션에서 일관성 없는 데이터를 허용하도록 하는 수준입니다.

DB는 ACID 특징과 같이 트랜잭션이 독립적인 수행을 하도록 해야하기 때문에, Lockin을 통해 트랜잭션이 DB를 다루는 동안에는 다른 트랜잭션이 관여하지 못하도록 해야합니다.

하지만 무조건적인 Locking으로 수많은 트랜잭션들을 순서대로 처리하게 된다면 DB의 성능은 떨어지게 될 것입니다. 따라서 효율적인 Locking 방법인 고립 수준을 나누어 처리하게 하는 방식이 필요합니다.

**참고 자료**: [트랜잭션 격리 수준(Transaction Isolation Level) | 👨🏻‍💻 Tech Interview](https://gyoogle.dev/blog/computer-science/data-base/Transaction%20Isolation%20Level.html)

</details>

---

## 문제 11

**유형**: 객관식

**문제**: 다음 중 비관계형 데이터베이스(NoSQL)의 특징으로 옳은 것을 모두 고르시오.

**보기**:

1. 스키마가 유연하며, 데이터 구조를 사전에 엄격하게 정의할 필요가 없다.
2. 일반적으로 수직적 확장(Scale-up)보다 수평적 확장(Scale-out)에 최적화되어 있다.
3. 모든 NoSQL 데이터베이스가 ACID 특성을 완벽하게 보장한다.
4. 문서(Document), 키-값(Key-Value), 그래프(Graph), 컬럼(Column) 기반 등 다양한 형태로 데이터를 저장할 수 있다.
5. 관계형 데이터베이스보다 복잡한 JOIN 연산을 지원하여 성능이 우수하다.

<details>
<summary>정답 확인하기</summary>

**정답**: 1, 2, 4

**해설**:

- NoSQL은 유연한 스키마를 제공하여 데이터 구조 변경이 쉽다.
- NoSQL은 여러 대의 서버를 활용하는 수평적 확장에 강하다.
- 일부 NoSQL은 ACID를 지원하지만, 일반적으로 CAP 이론에 따라 일관성을 일부 회생하고 가용성을 높이는 경우가 많음.
- NoSQL은 문서형(DB), 키-값 저장소, 컬럼형(DB), 그래프형(DB) 등 다양한 방식으로 데이터를 저장할 수 있다.
- NoSQL은 관계형 DB처럼 복잡한 JOIN을 지원하지 않으며, JOIN 없이 데이터를 설계하는 것이 일반적이다.

</details>

---

## 문제 12

**유형**: 객관식

**문제**: 다음 중 정규화(Normalization)에 대한 설명으로 옳은 것을 모두 고르시오.

**보기**:

1. 정규화는 데이터의 중복을 최소화하고 데이터 무결성을 유지하기 위한 과정이다.
2. 정규화는 항상 5NF(제5정규형)까지 진행해야만 데이터베이스의 성능이 최적화된다.
3. 정규화를 하면 항상 성능이 향상되며, 조인 연산이 줄어들어 속도가 빨라진다.
4. 정규화를 적용하면 데이터 삽입, 수정, 삭제 시 이상(Anomaly)을 줄일 수 있다.
5. 정규화된 데이터베이스는 경우에 따라 성능을 위해 역정규화(Denormalization)를 진행할 수도 있다.

<details>
<summary>정답 확인하기</summary>

**정답**: 1, 4, 5

**해설**:

- 정규화는 데이터 중복을 줄이고 무결성을 유지하는 것이 주요 목적이다.
- 5NF까지 꼭 진행해야 하는 것은 아님. 실무에서는 3NF(제3정규형)나 BCNF(보이스-코드 정규형)까지만 진행하는 경우가 많다.
- 정규화를 하면 조인이 많아질 수 있어, 성능이 항상 향상되는 것은 아님. 경우에 따라 조인이 많아져 성능이 저하될 수도 있음.
- 정규화를 하면 삽입 이상, 갱신 이상, 삭제 이상과 같은 문제를 줄일 수 있음.
- 실무에서는 성능을 위해 정규화를 일부 해제하는 역정규화(Denormalization)를 적용하기도 함.

</details>

---

## 문제 13

**유형**: 서술형

**문제**: 기본키, 후보키, 외래키, 슈퍼키에 대해 설명하시오.

<details>
<summary>정답 확인하기</summary>

**해설**:

#### 기본키

테이블에서 각 행을 유일하게 식별할 수 있는 키

- 유일성 : 한 테이블 내에서 같은 기본키 값을 가지는 행이 존재할 수 없음
- 최소성 : 꼭 필요한 속성만으로 구성됨 (불필요한 속성은 포함하지 않음)
- NULL값 불가능
- 테이블당 1개만 존재 가능
- 자동 인덱싱

#### 후보키

기본키가 될 수 있는 후보군 (여러 개 중에서 하나를 기본키로 선택)

- 유일성 : 후보키의 값은 테이블 내에서 중복될 수 없음
- 최소성 : 꼭 필요한 속성만으로 구성됨 (불필요한 속성은 포함하지 않음)
- 하나 이상의 후보키가 존재할 수 있음
- 기본키로 선택되지 않은 후보키도 존재 가능

#### 외래키

다른 테이블의 기본키를 참조하는 속성

- 참조 무결성 유지 : 외래키가 참조하는 기본키 값은 항상 유효해야 함
- NULL 허용 가능
- 기본키가 아닌 속성도 외래키가 될 수 있음 (단, unique해야 함)

#### 슈퍼키

테이블의 특정 행을 유일하게 식별할 수 있는 속성들의 집합

- 유일성 : 테이블에서 특정 행을 식별할 수 있음
- 최소성 만족 X : 필요 없는 속성이 포함될 수도 있음
- 후보키와 기본키도 슈퍼키의 일종

</details>

---

## 문제 14

**유형**: 서술형

**문제**: cascading에 대해 설명하시오.

<details>
<summary>정답 확인하기</summary>

**해설**:

외래키(Foreign Key) 관계에서 부모 테이블의 데이터 변경이 자식 테이블에 자동으로 전파되도록 설정하는 기능

- 부모 삭제 시, 자식도 같이 삭제하는 경우 : `ON DELETE CASCADE`
- 부모 삭제 시, 자식의 외래키 값을 NULL로 설정하는 경우 : `ON DELETE SET NULL`
- 부모의 키 값 변경 시, 자식의 외래키 값도 같이 변경하는 경우 : `ON UPDATE CASCADE`
- 부모가 삭제될 때 자식이 존재하면 삭제를 막고 싶은 경우 : `ON DELETE RESTRICT`

</details>

---

## 문제 15

**유형**: 객관식

**문제** 다음 트랜잭션의 결과로 알맞은것은?

```
트랜잭션 T1:                     트랜잭션 T2:
--------------------------------------
READ(A, a)
a = a - 50
WRITE(A, a)
                               READ(A, b)
                               b = b * 2
                               WRITE(A, b)
READ(B, a)
a = a + 50
WRITE(B, a)
COMMIT
                               READ(B, b)
                               b = b - 10
                               WRITE(B, b)
                               COMMIT
```

초기값이 A = 100, B = 100 일 때, 두 트랜잭션이 모두 완료된 후 A와 B의 값은?

1. A = 50, B = 140
2. A = 100, B = 140
3. A = 50, B = 150
4. A = 100, B = 150

<details>
<summary>정답 확인하기</summary>

**정답** : 2

**해설**
T1: A를 읽음 (a = 100)

T1: a = a - 50 (a = 50)

T1: A에 50을 씀 (A = 50)

T2: A를 읽음 (b = 50)

T2: b = b \* 2 (b = 100)

T2: A에 100을 씀 (A = 100)

T1: B를 읽음 (a = 100)

T1: a = a + 50 (a = 150)

T1: B에 150을 씀 (B = 150)

T1: 커밋 (T1의 변경사항 확정, 하지만 A는 이미 T2에 의해 100으로 변경)

T2: B를 읽음 (b = 150)

T2: b = b - 10 (b = 140)

T2: B에 140을 씀 (B = 140)

</details>

---

## 문제 16

**유형**: 객관식

**문제**: 다음 SQL 쿼리 실행 결과로 반환되는 행의 수는?

```sql
SELECT department_id, COUNT(*) as emp_count
FROM employees
WHERE salary > 5000
GROUP BY department_id
HAVING COUNT(*) > 3
ORDER BY emp_count DESC;
```

1. employees 테이블의 모든 행을 department_id별로 그룹화한 결과를 반환한다
2. 급여가 5000을 초과하는 직원이 3명 이상인 부서들을 직원 수 기준 오름차순으로 정렬한다
3. 급여가 5000을 초과하는 직원이 3명 이상인 부서들을 직원 수 기준 내림차순으로 정렬한다
4. 급여가 5000을 초과하는 직원이 가장 많은 부서 하나만 반환한다
5. department_id가 가장 큰 값을 가진 부서의 직원 수를 반환한다

<details>
<summary>정답 확인하기</summary>

**정답**: 3

**해설**:

FROM employees: employees 테이블에서 데이터를 가져온다.

WHERE salary > 5000: 급여가 5000을 초과하는 직원들만 선택한다.

GROUP BY department_id: 부서 ID별로 데이터를 그룹화한다.

COUNT(_): 각 부서별로 직원 수를 계산한다.

HAVING COUNT(_) > 3: 직원 수가 3명을 초과하는 부서만 선택한다.

ORDER BY emp_count DESC: 결과를 직원 수(emp_count)를 기준으로 내림차순 정렬한다.

</details>
