## 문제 1

**유형**: OX형

**문제**: 가변 분할 방식은 매 시점 프로그램의 크기에 맞게 동적으로 메모리를 나눠 사용하는 방식으로, 내부 단편화가 발생할 수 있다. ( O / X )

<details>
<summary>정답 확인하기</summary>

**정답**: X → 내부단편화가 아닌, 외부 단편화가 발생할 수 있습니다.

**해설**: 가변 분할 방식은 매 시점 프로그램의 크기에 맞게 동적으로 메모리를 나눠 사용합니다. 내부 단편화는 발생하지 않고, 외부 단편화는 발생할 수 있습니다. 가변 분할 방식 종류에는 최초적합(first fit), 최적접합(best fit), 최악적합(worst fit)이 있습니다.

</details>

## 문제 2

**유형**: OX형

**문제**: 세그멘테이션 방식에서는 동일한 크기의 세그만트가 할당되므로 내부 단편화가 발생할 가능성이 크다. ( O / X )

<details>
<summary>정답 확인하기</summary>

**정답**: X

**해설**: 세그멘테이션은 논리적인 단위로 가변 크기로 할당되므로 내부 단편화는 적지만, 외부 단편화가 발생할 수 있음

</details>

## 문제 3

**유형**: OX형

**문제**: 하나의 프로세스에 여러 개의 스레드가 있다고 가정하면, 각 스레드는 프로세스의 코드, 데이터, 스택 영역을 공유한다. ( O / X )

<details>
<summary>정답 확인하기</summary>

**정답**: X

**해설**: 하나의 프로세스 내의 스레드들은 코드, 데이터, 힙 영역을 공유하지만, 각 스레드는 독립적인 스택 영역을 가집니다. 스택 영역은 함수 호출 시 매개변수, 반환 주소, 지역 변수 등을 저장하는 공간으로, 스레드마다 개별적으로 할당됩니다.

</details>


## 문제 4

**유형**: 객관식

**문제**: 운영체제의 역할 중 적절한 것을 모두 고르시오.
   1. CPU 소유권을 어떤 프로세스에 할당할지, 프로세스 생성과 삭제, 자원 할당 및 반환을 관리합니다.
   2. 한정된 메모리를 어떤 프로세스에 얼마큼 할당해야 하는지 관리합니다.
   3. 디스크 파일을 어떠한 방법으로 보관할지 관리합니다.
   4. I/O 디바이스들인 마우스, 키보드와 컴퓨터 간에 데이터를 주고받는 것을 관리합니다.

<details>
<summary>정답 확인하기</summary>

**정답**: a, b, c, d

**해설**: 운영체제 <br/>
       - 정의: 사용자가 컴퓨터를 쉽게 다루게 해주는 인터페이스입니다. <br/>
       - 운영체제 종류: Window, Linux, iOS, android, macOS <br/>
       - 운영체제의 역할 <br/>
         1. CPU 스케줄링과 프로세스 관리: CPU 소유권을 어떤 프로세스에 할당할지, 프로세스 생성과 삭제, 자원 할당 및 반환을 관리합니다. <br/>
         2. 메모리 관리: 한정된 메모리를 어떤 프로세스에 얼마큼 할당해야 하는지 관리합니다. <br/>
         3. 디스크 파일을 어떠한 방법으로 보관할지 관리합니다. <br/>
         4. I/O 디바이스 관리: I/O 디바이스들인 마우스, 키보드와 컴퓨터 간에 데이터를 주고받는 것을 관리합니다. <br/>

</details>   
     

## 문제 5

**유형**: 객관식

**문제**: 세마포어와 뮤텍스의 차이점 중 옳은 것을 모두 고르시오.
   1. Mutex는 동기화 대상이 오직 1개일 때 사용하며, Semaphore는 동기화 대상이 1개 이상일 때 사용합니다.
   2. Mutex는 자원을 소유할 수 있고, 책임을 가지는 반면 Semaphore는 자원 소유가 불가합니다.
   3. Mutex는 상태가 0, 1 뿐이므로 Lock을 가질 수 있고, 소유하고 있는 스레드만이 이 Mutex를 해제할 수 있습니다. 반면 Semaphore는 Semaphore를 소유하지 않는 스레드가 Semaphore를 해제할 수 있습니다.
   4. Semaphore는 시스템 범위에 걸쳐 있고, 파일 시스템 상의 파일로 존재합니다. 반면, Mutex는 프로세스의 범위를 가지며 프로세스 종료될 때 자동으로 Clean up 됩니다.

<details>
<summary>정답 확인하기</summary>

**정답**: a, b, c, d

**해설**
- Mutex (뮤텍스): 공유된 자원의 데이터 혹은 임계영역 등에 하나의 프로세스 혹은 스레드가 접근하는 것을 막아줌 (동기화 대상이 하나)
- Semaphore (세마포어): 공유된 자원의 데이터 혹은 임계영역 등에 여러 프로세스 혹은 스레드가 접근하는 것을 막아줌 (동기화 대상이 하나 이상)
- 뮤텍스와 세마포어는 모두 완벽한 기법은 아니므로 데이터 무결성을 보장할 수 없으며 모든 교착상태를 해결하지는 못합니다. 하지만 상호배제를 위한 기본적인 문법입니다.
- 참고 자료: https://heeonii.tistory.com/14

</details>

## 문제 6

**유형**: 객관식

**문제**: Deadlock(교착상태) 관한 설명 중 옳지 않은 것을 모두 고르시오.
   1. 현대 운영체제는 교착 상태 해결 방법으로 ‘은행원 알고리즘’을 채택했다.
   2. 프로세스를 실행하다 ‘응답 없음’이라고 뜨는 원인 중 하나는 교착상태이다.
   3. 다른 프로세스의 자원을 강제적으로 가져올 수 없는 상태는 데드락의 원인 중 하나이다.
   4. 교착상태는 4가지 발생 조건이 모두 동시에 성립될때만 발생한다.

<details>
<summary>정답 확인하기</summary>

**정답**: a

**해설**
- 교착상태
  - 설명: 두 개 이상의 프로세스들이 서로가 가진 자원을 기다리며 중단된 상태를 말하고, 4가지 발생 조건이 동시에 성립할 때만 발생합니다.
  - 교착 상태의 원인
    1. 비선점: 다른 프로세스의 자원을 강제적으로 가져올 수 없습니다.
    2. 점유 대기: 특정 프로세스가 점유한 자원을 다른 프로세스가 요청하는 상태입니다.
    3. 순환(환형) 대기: 프로세스 A는 프로세스 B의 자원을 요구하고, 프로세스 B는 프로세스 A의 자원을 요구하는 등 서로가 서로의 자원을 요구하는 상황을 말합니다.
    4. 상호 배제: 한 프로세스가 자원을 독점하고 있으며 다른 프로세스들은 접근이 불가능합니다.
  - 교착 상태의 해결 방법
    1. 자원을 할당할 대 애초에 조건이 성립되지 않도록 설계합니다.
    2. 교착 상태 가능성이 없을 때만 자원 할당되며, 프로세스당 요청할 자원들의 최대치를 통해 자원 할당 가능 여부를 파악하는 ‘은행원 알고리즘’을 씁니다.
    3. 교착 상태가 발생하면 사이클이 있는지 찾아보고 이에 관련된 프로세스를 한 개 씩 지웁니다.
    4. 교착 상태는 매우 드물게 일어나기 때문에 이를 처리하는 비용이 더 커서 교착 상태가 발생하면 사용자가 작업을 종료합니다. 현대 운영체제는 이 방법을 채택했습니다. 예를 들어 프로세스를 실행시키다 ‘응답 없음’이라고 뜰 때가 있죠? 교착 상태가 발생한 경우에 이와 같은 경우가 발생하기도 합니다.

</details>

## 문제 7

**유형**: 객관식

**문제**: 다음 설명은 실행 방식 중 무엇에 해당할까요?

![alt text](<image (16).png>)

   1. blocking + sync
   2. blocking + async
   3. non-blocking + async
   4. non-blocking + sync

<details>
<summary>정답 확인하기</summary>

**정답**: 4

**해설**
1. blocking + sync : 다른 작업이 진행되는 동안 자신의 작업을 처리하지 않고 (blocking), 다른 작업의 완료 여부를 바로 받아 순차적으로 처리하는 (sync) 방식이다. 다른 작업의 결과가 자신의 작업에 영향을 주는 경우에 활용할 수 있다.
2. blocking + async : 다른 작업이 진행되는 동안 자신의 작업을 멈추고 기다리는 (blocking), 다른 작업의 결과를 바로 처리하지 않아 순서대로 작업을 수행하지 않는 (async) 방식이다.
3. non-blocking + async : 다른 작업이 진행되는 동안에도자신의 작업을 처리하고 (non-blocking), 다른 작업의 결과를 바로 처리하지 않아 작업 순서가 지켜지지 않는 (async) 방식이다. 다른 작업의 결과가 자신의 작업에 영향을 주지 않는 경우에 활용할 수 있다.
4. non-blocking + sync : 다른 작업이 진행되는 동안에도 자신의 작업을 처리하고 (non-blocking), 다른 작업의 결과를 바로 처리하여 작업을 순차대로 수행하는 (sync) 방식이다.

**참고 자료**: [https://inpa.tistory.com/entry/👩‍💻-동기비동기-블로킹논블로킹-개념-정리](https://inpa.tistory.com/entry/%F0%9F%91%A9%E2%80%8D%F0%9F%92%BB-%EB%8F%99%EA%B8%B0%EB%B9%84%EB%8F%99%EA%B8%B0-%EB%B8%94%EB%A1%9C%ED%82%B9%EB%85%BC%EB%B8%94%EB%A1%9C%ED%82%B9-%EA%B0%9C%EB%85%90-%EC%A0%95%EB%A6%AC)

</details>

## 문제 8

**유형**: 주관식

**문제**: 운영체제에서 실제 물리적 메모리 크기보다 더 큰 메모리를 사용할 수 있도록 제공하는 기능은 무엇인가요?

<details>
<summary>정답 확인하기</summary>

**정답**: 가상메모리

**해설**: 실제 물리적 메모리보다 더 큰 메모리를 사용할 수 있도록 운영체제가 제공하는 기능. 필요한 데이터만 메모리에 올리고 나머지는 디스크에 저장하여, 메모리 부족 문제를 해결할 수 있다.

</details>


## 문제 9

**유형**: 주관식

**문제**: 캐시와 CDN 둘 다 데이터를 빠르게 가져오는 역할을 하는데, 차이점으로는 무엇이 있나요?

<details>
<summary>정답 확인하기</summary>

**정답**: 목적과 동작 방식에서 차이가 있습니다.
       캐시는 자주 사용되는 데이터를 임시 저장하여 재사용성을 극대화하고, 반복적인 요청 시 빠르게 반환하는 방식입니다.
       CDN은 사용자와 가까운 서버(엣지 서버)에서 데이터를 제공하여 네트워크 지연을 줄이고 로딩 속도를 최적화하는 방식입니다.

</details>

## 문제 10

**유형**: 주관식

**문제**: SJF 방식으로 평균 대기시간을 구하시오.

![alt text](<image (17).png>)

<details>
<summary>정답 확인하기</summary>

**정답**
- 실행 순서: P4 → P1→ P2 → P3
- 평균 대기 시간: (0 + 3 + 9 + 16) / 4 = **7**

**해설**
- CPU 스케줄러
  - 정의: 실행 가능한 프로세스 중 하나를 선택해 CPU를 할당하는 역할을 하며, FCFS, SJF, STRF, RR, 우선순위 스케줄링 등의 방식이 있다.
  - `FCFS` (First Come First Served) → 먼저 CPU를 요청하는 프로세스를 먼저 처리하는 방식 (waiting time이 길어진다)
  - `SJF` (Shortest Job First) → 가장 적게 걸리는 프로세스를 먼저 실행 시킴 (가장 짧은 waiting time 보장) → Starvation발생 가능. 짧은 것들만 실행하면 긴 프로세스는 계속 기다린다.
  - `SRTF` (Shortest Remaining Time First) → 각 task의 남은 시간을 따져보고 가장 짧은 녀석에게 CPU를 할당하는 방식.
  - `RR` (Round Robin) → 모든 job을 time slice 크기로 쪼개고, 한 slice씩 모든 task들을 공평하게 돌리는 방식
  - `Priority Scheduling` (우선 순위 스케줄링) → 우선순위에 따라서 실행순서를 정해주는 방식 (우선 순위는 시간 제한, 메모리 요구량, 프로세스의 중요성, 자원사용 비용 등에 따라 달라짐) → 우선 순위가 같을 경우 FCFS와 다를게 없다.

</details>
