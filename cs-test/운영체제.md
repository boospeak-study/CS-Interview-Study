## 문제 1

**유형**: OX형

**문제**: 가변 분할 방식은 매 시점 프로그램의 크기에 맞게 동적으로 메모리를 나눠 사용하는 방식으로, 내부 단편화가 발생할 수 있다.

<details>
<summary>정답 확인하기</summary>

**정답**: X → 내부단편화가 아닌, 외부 단편화가 발생할 수 있습니다.

**해설**: 가변 분할 방식은 매 시점 프로그램의 크기에 맞게 동적으로 메모리를 나눠 사용합니다. 내부 단편화는 발생하지 않고, 외부 단편화는 발생할 수 있습니다. 가변 분할 방식 종류에는 최초적합(first fit), 최적접합(best fit), 최악적합(worst fit)이 있습니다.

</details>

## 문제 2

**유형**: OX형

**문제**: 세그멘테이션 방식에서는 동일한 크기의 세그만트가 할당되므로 내부 단편화가 발생할 가능성이 크다.

<details>
<summary>정답 확인하기</summary>

**정답**: X

**해설**: 세그멘테이션은 논리적인 단위로 가변 크기로 할당되므로 내부 단편화는 적지만, 외부 단편화가 발생할 수 있음

</details>

## 문제 3

**유형**: OX형

**문제**: 하나의 프로세스에 여러 개의 스레드가 있다고 가정하면, 각 스레드는 프로세스의 코드, 데이터, 스택 영역을 공유한다.

<details>
<summary>정답 확인하기</summary>

**정답**: X

**해설**: 하나의 프로세스 내의 스레드들은 코드, 데이터, 힙 영역을 공유하지만, 각 스레드는 독립적인 스택 영역을 가집니다. 스택 영역은 함수 호출 시 매개변수, 반환 주소, 지역 변수 등을 저장하는 공간으로, 스레드마다 개별적으로 할당됩니다.

</details>

## 문제 4

**유형**: 객관식

**문제**: 운영체제의 역할 중 적절한 것을 모두 고르시오.

1.  CPU 소유권을 어떤 프로세스에 할당할지, 프로세스 생성과 삭제, 자원 할당 및 반환을 관리합니다.
2.  한정된 메모리를 어떤 프로세스에 얼마큼 할당해야 하는지 관리합니다.
3.  디스크 파일을 어떠한 방법으로 보관할지 관리합니다.
4.  I/O 디바이스들인 마우스, 키보드와 컴퓨터 간에 데이터를 주고받는 것을 관리합니다.

<details>
<summary>정답 확인하기</summary>

**정답**: 1, 2, 3, 4

**해설**: 운영체제 <br/> - 정의: 사용자가 컴퓨터를 쉽게 다루게 해주는 인터페이스입니다. <br/> - 운영체제 종류: Window, Linux, iOS, android, macOS <br/> - 운영체제의 역할 <br/> 1. CPU 스케줄링과 프로세스 관리: CPU 소유권을 어떤 프로세스에 할당할지, 프로세스 생성과 삭제, 자원 할당 및 반환을 관리합니다. <br/> 2. 메모리 관리: 한정된 메모리를 어떤 프로세스에 얼마큼 할당해야 하는지 관리합니다. <br/> 3. 디스크 파일을 어떠한 방법으로 보관할지 관리합니다. <br/> 4. I/O 디바이스 관리: I/O 디바이스들인 마우스, 키보드와 컴퓨터 간에 데이터를 주고받는 것을 관리합니다. <br/>

</details>

## 문제 5

**유형**: 객관식

**문제**: 세마포어와 뮤텍스의 차이점 중 옳은 것을 모두 고르시오.

1.  Mutex는 동기화 대상이 오직 1개일 때 사용하며, Semaphore는 동기화 대상이 1개 이상일 때 사용합니다.
2.  Mutex는 자원을 소유할 수 있고, 책임을 가지는 반면 Semaphore는 자원 소유가 불가합니다.
3.  Mutex는 상태가 0, 1 뿐이므로 Lock을 가질 수 있고, 소유하고 있는 스레드만이 이 Mutex를 해제할 수 있습니다. 반면 Semaphore는 Semaphore를 소유하지 않는 스레드가 Semaphore를 해제할 수 있습니다.
4.  Semaphore는 시스템 범위에 걸쳐 있고, 파일 시스템 상의 파일로 존재합니다. 반면, Mutex는 프로세스의 범위를 가지며 프로세스 종료될 때 자동으로 Clean up 됩니다.

<details>
<summary>정답 확인하기</summary>

**정답**: 1, 2, 3, 4

**해설**

- Mutex (뮤텍스): 공유된 자원의 데이터 혹은 임계영역 등에 하나의 프로세스 혹은 스레드가 접근하는 것을 막아줌 (동기화 대상이 하나)
- Semaphore (세마포어): 공유된 자원의 데이터 혹은 임계영역 등에 여러 프로세스 혹은 스레드가 접근하는 것을 막아줌 (동기화 대상이 하나 이상)
- 뮤텍스와 세마포어는 모두 완벽한 기법은 아니므로 데이터 무결성을 보장할 수 없으며 모든 교착상태를 해결하지는 못합니다. 하지만 상호배제를 위한 기본적인 문법입니다.
- 참고 자료: https://heeonii.tistory.com/14

</details>

## 문제 6

**유형**: 객관식

**문제**: Deadlock(교착상태) 관한 설명 중 옳지 않은 것을 모두 고르시오.

1.  현대 운영체제는 교착 상태 해결 방법으로 ‘은행원 알고리즘’을 채택했다.
2.  프로세스를 실행하다 ‘응답 없음’이라고 뜨는 원인 중 하나는 교착상태이다.
3.  다른 프로세스의 자원을 강제적으로 가져올 수 없는 상태는 데드락의 원인 중 하나이다.
4.  교착상태는 4가지 발생 조건이 모두 동시에 성립될때만 발생한다.

<details>
<summary>정답 확인하기</summary>

**정답**: 1

**해설**

- 교착상태
  - 설명: 두 개 이상의 프로세스들이 서로가 가진 자원을 기다리며 중단된 상태를 말하고, 4가지 발생 조건이 동시에 성립할 때만 발생합니다.
  - 교착 상태의 원인
    1. 비선점: 다른 프로세스의 자원을 강제적으로 가져올 수 없습니다.
    2. 점유 대기: 특정 프로세스가 점유한 자원을 다른 프로세스가 요청하는 상태입니다.
    3. 순환(환형) 대기: 프로세스 A는 프로세스 B의 자원을 요구하고, 프로세스 B는 프로세스 A의 자원을 요구하는 등 서로가 서로의 자원을 요구하는 상황을 말합니다.
    4. 상호 배제: 한 프로세스가 자원을 독점하고 있으며 다른 프로세스들은 접근이 불가능합니다.
  - 교착 상태의 해결 방법
    1. 자원을 할당할 대 애초에 조건이 성립되지 않도록 설계합니다.
    2. 교착 상태 가능성이 없을 때만 자원 할당되며, 프로세스당 요청할 자원들의 최대치를 통해 자원 할당 가능 여부를 파악하는 ‘은행원 알고리즘’을 씁니다.
    3. 교착 상태가 발생하면 사이클이 있는지 찾아보고 이에 관련된 프로세스를 한 개 씩 지웁니다.
    4. 교착 상태는 매우 드물게 일어나기 때문에 이를 처리하는 비용이 더 커서 교착 상태가 발생하면 사용자가 작업을 종료합니다. 현대 운영체제는 이 방법을 채택했습니다. 예를 들어 프로세스를 실행시키다 ‘응답 없음’이라고 뜰 때가 있죠? 교착 상태가 발생한 경우에 이와 같은 경우가 발생하기도 합니다.

</details>

## 문제 7

**유형**: 객관식

**문제**: 다음 설명은 실행 방식 중 무엇에 해당할까요?

![alt text](<image (16).png>)

1.  blocking + sync
2.  blocking + async
3.  non-blocking + async
4.  non-blocking + sync

<details>
<summary>정답 확인하기</summary>

**정답**: 4

**해설**

1. blocking + sync : 다른 작업이 진행되는 동안 자신의 작업을 처리하지 않고 (blocking), 다른 작업의 완료 여부를 바로 받아 순차적으로 처리하는 (sync) 방식이다. 다른 작업의 결과가 자신의 작업에 영향을 주는 경우에 활용할 수 있다.
2. blocking + async : 다른 작업이 진행되는 동안 자신의 작업을 멈추고 기다리는 (blocking), 다른 작업의 결과를 바로 처리하지 않아 순서대로 작업을 수행하지 않는 (async) 방식이다.
3. non-blocking + async : 다른 작업이 진행되는 동안에도자신의 작업을 처리하고 (non-blocking), 다른 작업의 결과를 바로 처리하지 않아 작업 순서가 지켜지지 않는 (async) 방식이다. 다른 작업의 결과가 자신의 작업에 영향을 주지 않는 경우에 활용할 수 있다.
4. non-blocking + sync : 다른 작업이 진행되는 동안에도 자신의 작업을 처리하고 (non-blocking), 다른 작업의 결과를 바로 처리하여 작업을 순차대로 수행하는 (sync) 방식이다.

**참고 자료**: [https://inpa.tistory.com/entry/👩‍💻-동기비동기-블로킹논블로킹-개념-정리](https://inpa.tistory.com/entry/%F0%9F%91%A9%E2%80%8D%F0%9F%92%BB-%EB%8F%99%EA%B8%B0%EB%B9%84%EB%8F%99%EA%B8%B0-%EB%B8%94%EB%A1%9C%ED%82%B9%EB%85%BC%EB%B8%94%EB%A1%9C%ED%82%B9-%EA%B0%9C%EB%85%90-%EC%A0%95%EB%A6%AC)

</details>

## 문제 8

**유형**: 주관식

**문제**: 운영체제에서 실제 물리적 메모리 크기보다 더 큰 메모리를 사용할 수 있도록 제공하는 기능은 무엇인가요?

<details>
<summary>정답 확인하기</summary>

**정답**: 가상메모리

**해설**: 실제 물리적 메모리보다 더 큰 메모리를 사용할 수 있도록 운영체제가 제공하는 기능. 필요한 데이터만 메모리에 올리고 나머지는 디스크에 저장하여, 메모리 부족 문제를 해결할 수 있다.

</details>

## 문제 9

**유형**: 주관식

**문제**: 캐시와 CDN 둘 다 데이터를 빠르게 가져오는 역할을 하는데, 차이점으로는 무엇이 있나요?

<details>
<summary>정답 확인하기</summary>

**정답**: 목적과 동작 방식에서 차이가 있습니다.
캐시는 자주 사용되는 데이터를 임시 저장하여 재사용성을 극대화하고, 반복적인 요청 시 빠르게 반환하는 방식입니다.
CDN은 사용자와 가까운 서버(엣지 서버)에서 데이터를 제공하여 네트워크 지연을 줄이고 로딩 속도를 최적화하는 방식입니다.

</details>

## 문제 10

**유형**: 주관식

**문제**: SJF 방식으로 평균 대기시간을 구하시오.

![alt text](<image (17).png>)

<details>
<summary>정답 확인하기</summary>

**정답**

- 실행 순서: P4 → P1 → P2 → P3
- 평균 대기 시간: (0 + 3 + 9 + 16) / 4 = **7**

**해설**

- CPU 스케줄러
  - 정의: 실행 가능한 프로세스 중 하나를 선택해 CPU를 할당하는 역할을 하며, FCFS, SJF, STRF, RR, 우선순위 스케줄링 등의 방식이 있다.
  - `FCFS` (First Come First Served) → 먼저 CPU를 요청하는 프로세스를 먼저 처리하는 방식 (waiting time이 길어진다)
  - `SJF` (Shortest Job First) → 가장 적게 걸리는 프로세스를 먼저 실행 시킴 (가장 짧은 waiting time 보장) → Starvation발생 가능. 짧은 것들만 실행하면 긴 프로세스는 계속 기다린다.
  - `SRTF` (Shortest Remaining Time First) → 각 task의 남은 시간을 따져보고 가장 짧은 녀석에게 CPU를 할당하는 방식.
  - `RR` (Round Robin) → 모든 job을 time slice 크기로 쪼개고, 한 slice씩 모든 task들을 공평하게 돌리는 방식
  - `Priority Scheduling` (우선 순위 스케줄링) → 우선순위에 따라서 실행순서를 정해주는 방식 (우선 순위는 시간 제한, 메모리 요구량, 프로세스의 중요성, 자원사용 비용 등에 따라 달라짐) → 우선 순위가 같을 경우 FCFS와 다를게 없다.

</details>

## 문제 11 

**유형** : OX형

**문제** : 병렬 처리(Parallelism)는 여러 작업이 정확히 동시에 실행되는 것을 의미하며, 반드시 여러 개의 물리적 CPU 코어가 필요하다.

<details>
<summary>정답 확인하기</summary>

**정답** : O

**해설** : 병렬 처리(Parallelism)는 실제로 여러 작업이 동시에 실행되는 것을 의미한다. 멀티 코어 환경에서 여러개의 코어에 작업을 각 코어로 분산시켜서 동시에 작업하는 것을 의미하며 실제 물리적으로 여러 작업이 동시에 실행되는 것이다.

**참고자료**
![병렬과 병행 이미지](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2F1Shns%2FbtqYusRR3n6%2FUUnBJ5Tqc0w7zIj5yBbRE1%2Fimg.png)

</details>

## 문제 12

**유형** : OX형

**문제** : 병행 처리(Concurrency)는 싱글 코어 CPU에서도 구현이 가능하다.

<details>
<summary>정답 확인하기</summary>

**정답** : O

**해설** : 병행 처리(Concurrency)는 여러 작업이 논리적으로 동시에 진행되는 것처럼 보이는 것으로, 싱글 코어에서도 시분할(time-slicing) 방식으로 구현 가능하다. 실제로는 빠르게 작업 간 전환이 일어나 동시에 실행되는 것처럼 보인다.

</details>

## 문제 13 

**유형**: 객관식

**문제**: 다음 중, 경쟁 상태(Race Condition)가 발생하는 상황은?

**보기**:

1. 커널 모드에서 데이터를 로드하여 작업을 수행하다가 인터럽트가 발생하여 같은 데이터를 조작하는 경우
2. 프로세스 A가 자신의 스택 영역에 있는 지역 변수를 조작하는 경우
3. 프로세스 A가 커널 모드에서 데이터를 조작하는 도중, 시간이 초과되어 CPU 제어권이 프로세스 B로 넘어가 같은 데이터를 조작하는 경우
4. 멀티 프로세서 환경에서 2개의 CPU가 동시에 커널 내부의 공유 데이터에 접근하여 조작하는 경우
5. 프로세스 A와 프로세스 B가 공유 메모리 영역에서 데이터를 읽는 경우

<details>
<summary>정답 확인하기</summary>

**정답**: 1, 3, 4

**해설**: 경쟁 상태란 공유 자원에 대해 여러 프로세스/스레드가 동시에 접근할 때, 결과값에 영향을 줄 수 있는 상태이다. 동시에 접근하면 자료의 일관성을 해치는 결과가 나타난다.

2: 스택 영역은 각 프로세스 or 스레드마다 독립적으로 할당되기 때문에 공유 자원이 아니다.

5: 공유 메모리 영역은 공유 자원이지만, 데이터를 읽기만 한다면 결과값에 영향을 주지 않는다.

**참고 자료**: [신입 개발자 기술면접 질문 정리 - 운영체제](https://dev-coco.tistory.com/162)

</details>

---

## 문제 14

**유형**: 객관식

**문제**: LRU 알고리즘을 사용하는 캐시의 크기가 4일 때, 참조 스트링이 1, 2, 3, 1, 4, 5을 처리하고 난 후 캐시의 내용은?

**보기**:

1. {4, 1, 3, 2}
2. {3, 1, 2, 5}
3. {5, 4, 2, 1}
4. {4, 3, 5, 2}
5. {5, 4, 1, 3}

<details>
<summary>정답 확인하기</summary>

**정답**: 5

**해설**:

- LRU 알고리즘은 페이지 교체 알고리즘 중 하나로, 가장 오랫동안 참조되지 않은 페이지를 교체한다.
- 캐시가 사용하는 리소스의 양은 제한되어 있고, 캐시는 제한된 리소스 내에서 데이터를 빠르게 저장하고 접근할 수 있어야 하기에 사용하는 알고리즘이다.

![](<./image%20(2).png>)

Input : 123145 인 상황에서
4초를 보면 원래 있었던 1이 한번 더 입력되므로 1을 참조한다. 참조 후 오랫동안 참조하지 않은 순으로 바꾸면 2->3->1이 된다.
6초에는 cache size가 가득차 5가 들어갈 수 없으므로, 가장 오랫동안 참조되지 않은 2를 제거한 후 저장한다.
Output : 5413

**참고 자료**: [LRU(Least Recently Used) 알고리즘 이란](https://velog.io/@ddyy094/LRULeast-Recently-Used-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EC%9D%B4%EB%9E%80)

</details>

## 문제 15

**유형**: 객관식

**문제**: 프로세스의 상태 전이에 대한 설명으로 올바르지 않은 것은?

**보기**:

1. 실행(Running) 상태의 프로세스는 I/O 요청이 발생하면 대기(Waiting) 상태로 전이될 수 있다.
2. 준비(Ready) 상태의 프로세스는 CPU 스케줄러에 의해 선택되면 실행(Running) 상태로 전이된다.
3. 대기(Waiting) 상태의 프로세스는 직접 실행(Running) 상태로 전이될 수 있다.
4. 생성(New) 프로세스는 메모리 등 필요한 자원이 할당되면 준비(Ready) 상태로 전이된다.
5. 실행(Running) 상태의 프로세스는 타임 슬라이스가 만료되면 준비(Ready) 상태로 전이될 수 있다.

<details>
<summary>정답 확인하기</summary>

**정답**: 3

**해설**: 대기(Waiting) 상태의 프로세스는 I/O 작업이 완료되면 직접 실행(Running) 상태로 전이되는 것이 아니라, 먼저 준비(Ready) 상태로 전이된다. 이후 CPU 스케줄러에 의해 선택되었을 때 비로소 실행(Running) 상태로 전이된다. 따라서 대기 상태에서 실행 상태로 직접 전이되는 것은 올바르지 않다.

프로세스의 기본적인 상태 전이는 다음과 같다.

- New → Ready: 프로세스 생성 후 준비 상태로 전이
- Ready → Running: CPU 스케줄러에 의해 선택되어 실행
- Running → Ready: 타임 슬라이스 종료나 선점으로 인해 다시 준비 상태로
- Running → Waiting: I/O 요청이나 이벤트 대기로 인해 대기 상태로
- Waiting → Ready: I/O 완료나 이벤트 발생 후 다시 준비 상태로
- Running → Terminated: 프로세스 실행 완료

</details>

---

## 문제 16

**유형**: 서술형

**문제**: convoy effect와 starvation의 차이에 대해 설명하시오.

<details>
<summary>정답 확인하기</summary>

**해설**:

convoy effect는 몇개의 시간이 오래 걸리는 프로세스로 인해 다른 프로세스의 실행이 느려지고 평균 대기시간이 길어지며 결과적으로 전체적인 프로세스의 성능을 저하시키는 현상입니다.
starvation은 어떤 프로세스가 무기한으로 대기하며 CPU소유권을 얻을 수 없는 현상입니다.

</details>

---

## 문제 17

**유형**: 서술형

**문제**: busy waiting에 대해 설명하시오.

<details>
<summary>정답 확인하기</summary>

**해설**:

busy waiting은 프로세스, 스레드가 어떠한 일을 실행하기 전에 만족하는 조건을 지속적으로 확인하는 동기화 기술입니다.

busy wait는 운영체제에서 프로세스가 공유자원에 동시에 접근하는 것을 방지하는 상호배제를 달성하는데 사용됩니다.
busy_wait 상태에서는 우선순위에 따라 작업을 바꿀 수 없기 때문에 우선 순위가 높은 작업을 완료해야 할 때 비효율적이며 대기시간이 많이 걸릴 경우 계속해서 기다리는데 CPU자원을 쓰기 때문에 자원낭비가 심하다는 단점이 있습니다.

</details>

---
