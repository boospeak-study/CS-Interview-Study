# 네트워크 기초

### 트래픽
특정시점에 링크 내에 흐르는 데이터의 양
- 100KB 이미지를 1,000명이 다운로드 시 누적 트래픽은? 100,000KB

### 처리량
링크 내에서 성공적으로 전달된 데이터의 양

### 대역폭
주어진 시간 동안 네트워크 연결을 통해 흐를 수 있는 최대 비트 수

---

## 네트워크 토폴로지
노드와 링크가 어떻게 구성되어있는지 종류에 따라 여러 토폴로지로 나뉨

### 버스 토폴로지
하나의 회선에 여러개의 노드가 연결된 방식

**장점**
- 노드 추가, 삭제가 쉬움
- 설치 비용 적음
- 소규모 네트워크를 구축하기에도 매우 쉬움
- 한 노드에 장애가 발생해도 다른 노드에 영향이 없음

**단점**
- 메인 링크에 많은 트래픽이 생기면 정체현상 발생가능성이 높아 패킷 손실율이 올라감
- 메인 링크에 장애가 발생하면 큰 문제

### 스타 토폴로지
중앙에 있는 노드를 기반으로 연결된 방식

**장점**
- 노드 추가, 삭제가 쉬움
- 중앙노드가 아닌 노드에 장애가 발생해도 다른 노드에 영향이 없음
- 안정성이 높음
    - 중앙노드가 아닌 한 노드에 문제 발생하더라도 중앙노드를 거쳐야하고, 중앙노드에는 방화벽이나 보안처리가 되어있음
- 한 링크에 장애를 받아도 나머지 부분은 정상작동

**단점**
- 중앙 노드에 장애가 발생하면 큰 문제

### 트리 토폴로지(계층적 토폴로지)
트리형태로 버스토폴로지와 스타토폴로지의 하이브리드 형태
노드를 추가하고 삭제하는데 보통(리프노드를 제외한 노드의 경우 확장이 어려움)

**장점**
- 노드 확장에 용이(주로 리프노드로 확장)
- 리프노드의 에러는 나머지 부분에 영향이 없음

**단점**
- 특정 노드에 트래픽 집중 시 하위 노드에 영향
- 루트 노드에 문제가 생기면 전체 네트워크에 문제

### 링 토폴로지
고리형태
토큰을 기반으로 연속적으로 노드를 거치며 통신권한 여부를 따지고 해당 권한이 없는 노드는 데이터를 받지 않음(토큰링 방식)

**장점**
- 노드 추가, 삭제가 쉬움
- 노드 수가 많아져도 데이터 손실이 없음

**단점**
- 링크 또는 노드가 하나만 에러가 발생해도 전체 네트워크에 영향
- 토큰이 없는 노드는 통신에 참여를 못하며 데이터 공유가 안됨

### 메시 토폴로지
그물망 형태로 풀(full)메시 토폴로지의 경우 n * (n - 1) / 2의 노선이 필요

**장점**
- 안정성이 높음
    - 한 노드가 장애가 나도 다른 노드에 영향을 미치지 않음
- 트래픽을 분산할 수 있음

**단점**
- 노드 추가, 삭제가 어려움
- 회선이 비효율적으로 많아 구축비용이 높음


### 병목현상(bottleneck)
트래픽에 의해 데이터 흐름이 제한된 상황

---

## 캐스트
### 유니캐스트
- 1:1 통신
    - 대표적으로 HTTP 통신
- 가장 일반적인 네트워크 전송 형태

### 멀티캐스트
- 1:N 통신
- 연결된 모든 노드가 아닌 특정 노드들에게만 데이터 전달

### 브로드캐스트
- 1:N 통신
- 그룹이 아닌 연결되어있는 모든 노드에 데이터를 전달
    - ARP

---

## 네트워크 분류
- LAN : 근거리 통신망(Local Area Network)
- MAN : 대도시 통신망(Metropolitan Area Network)
- WAN : 광역 통신망(Wide Area Network)

**사이즈**
LAN < MAN < WAN


# 계층

## OSI 7계층
OSI 모델은 네트워크 통신을 7개의 계층으로 나눈 모델
-> 실제 구현되어있지 않은 설계의 참조 모델

1. 물리 계층 (Physical Layer): 물리적인 신호 교환과 관련된 사항 담당
    - **리피터** : 들어오는 약해진 신호 정도를 증폭하여 다른 쪽으로 전달하는 장치
    - 기본 단위 : **비트**
2. 데이터 링크 계층 (Data Link Layer): 직접 연결된 노드 간의 신뢰성 있는 데이터 전송을 담당
    - **브리지** : 두 개의 LAN을 상호 접속할 수 있도록 하는 통신망 연결 장치
    - 기본 단위 : **프레임**
3. 네트워크 계층 (Network Layer): 다른 네트워크로 데이터를 전송하기 위한 경로 선택과 라우팅을 수행
    - **라우터** : 라우팅(하나 이상의 네트워크에서 경로를 선택하는 프로세스)을 하는 장비
    - 기본 단위 : **패킷**
4. 전송 계층 (Transport Layer): 데이터의 신뢰성 있고 효율적인 전송을 보장하며 오류 복구와 흐름 제어를 수행
5. 세션 계층 (Session Layer): 데이터 교환의 시작과 종료, 동기화를 담당
6. 표현 계층 (Presentation Layer): 데이터의 인코딩, 압축, 암호화 등을 처리하여 서로 다른 데이터 형식 간의 변환을 수행
7. 응용 계층 (Application Layer): 최종 사용자가 네트워크 서비스에 접근할 수 있도록 인터페이스를 제공

---

## TCP/IP 4계층
TCP/IP 모델은 네트워크 통신을 4개의 계층으로 나눈 모델

1. 네트워크 접근 계층 (Network Access Layer 또는 Link Layer): 하드웨어와 네트워크 드라이버를 관리하며, 데이터를 전송
    - OSI의 1, 2계층이 이에 해당
2. 인터넷 계층 (Internet Layer): IP 주소를 할당하고 데이터 패킷을 라우팅하며, 네트워크 간의 통신을 가능하게 함
    - OSI의 3계층
3. 전송 계층 (Transport Layer): 데이터 전송의 신뢰성을 보장하고, 데이터 흐름을 제어합니다. 주로 TCP와 UDP 프로토콜이 사용됨
    - OSI의 4계층
4. 응용 계층 (Application Layer): 최종 사용자와 상호작용하는 계층으로, HTTP, FTP, SMTP 등과 같은 프로토콜이 여기에 속함
    - OSI의 5, 6, 7계층이 이에 해당


# 3계층

ip subnet mask


# TCP & UDP

## TCP의 3-way handshake와 4-way handshake
TCP의 연결과정과 해제과정은 각각 **3-way handshake**, **4-way handshake** 과정을 겪습니다.

### 3-way handshake과정
클라이언트가 서버로 SYN를 보내 연결을 요청하고 서버에서 클라이언트로 SYN + ACK를 보냅니다. 이를 클라이언트에서 수신받으면 서버로 ACK를 보내며 TCP가 연결됩니다.

### 4-way handshake과정
클라이언트가 연결을 해제하기 위해 FIN요청을 보냅니다. 서버는 이를 받아 ACK를 보내고 남은 요청들을 처리 후 FIN을 클라이언트에게 보냅니다. 클라이언트가 이를 수신하여 ACK를 서버에게 보내고, 혹시나 지연된 데이터응답이 있을 수 있기에 일정시간 기다린 후 연결을 종료합니다.

---

## TCP와 UDP의 차이
TCP와 UDP는 둘다 OSI 7계층 중 전송계층에 해당하는 프로토콜입니다.
TCP는 **가상회선(Virtual Circuit)**을 사용하고 UDP는 **데이터그램(Datagram)**방식을 사용합니다.

### 가상회선 방식
가상회선 방식의 경우 초기 연결 설정이 필요합니다.
각각의 패킷은 독립적이지 않아서 고장난 링크나 노드를 만나면 새로운 연결을 설정해야 하는 **stateful**방식입니다.

### 데이터그램 방식
데이터그램 방식의 경우 초기 연결 설정을 하지 않습니다.
또한, 각각의 패킷은 독립적으로 포워드하기 때문에 보낸순서와 받는순서가 다를 수 있습니다.
포워딩 과정 중 고장난 링크나 노드를 우회하여 라우팅을 하는 **stateless**방식이지만 인터넷의 경우 라우팅 테이블에 timeout(TTL)을 두어 stateful과 stateless가 공존하는 **soft state**상태입니다.

### 차이 정리

| 특성                 | TCP                           | UDP                                |
|----------------------|-------------------------------|------------------------------------|
| 연결 설정             | 가상회선 방식 (Connection-oriented) | 데이터그램 방식 (Connectionless)       |
| 패킷 순서 보장        | 보장됨 (Ordered delivery)      | 보장되지 않음 (Unordered delivery)   |
| 신뢰성                | 높음 (Reliable)               | 낮음 (Unreliable)                   |
| 속도                  | 상대적으로 느림               | 상대적으로 빠름                      |
| 사용 예시             | 파일 전송, 이메일 등         | 스트리밍, 동영상 전송 등             |
| 브로드캐스트 지원     | 지원 안 함                    | 지원 함                              |



# TCP 제어

## TCP 오류 제어
TCP는 오류를 검출하게 되면 재전송의 방식으로 오류를 제어한다.
TCP가 오류를 검출하는 방법은 2가지가 있다.
- 중복된 ACK 세그먼트를 수신했을 때
- 타임아웃이 발생했을 때

### 재전송 기법
재전송 기법 : ARQ(Auotomatic Repeat Request, 자동 재전송 요구)
- 수신 호스트의 답변(ACK)과 타임아웃을 토대로 문제를 진단
- 문제가 생긴 메시지를 재전송함으로써 신뢰성을 확보하는 방식

#### ARQ의 3가지 방식
- Stop-and-Wait ARQ
- Go-Back-N ARQ
- Selective Repeat ARQ

### Stop-and-Wait ARQ
- 송신 측이 하나의 패킷을 보낸 후, **수신 측의 확인 응답(ACK)**을 받을 때까지 대기하는 방식
- 장점 : 단순하지만, 높은 신뢰성
- 단점 : 네트워크의 이용 효율이 낮아지고 성능 저하

#### Stop-and-Wait의 문제를 해결하는 방법
각 세그먼트에 대한 ACK 세그먼트가 도착하기 전이더라도 여러 세그먼트를 보낼 수 있어야 함
- 파이프라이닝 : 연속해서 메시지를 보낼 수 있는 기술

### Go-Back-N ARQ
- **Stop-and-Wait**의 단점을 보안한 파이프라이닝 전송 방식식
- 송신자는 윈도우 크기(N)만큼 여러 개의 패킷을 연속 전송 가능
- 수신 측에서 오류가 발생하면 이후 **모든 패킷을 폐기하고 재전송**

### Selective Repeat ARQ
- **Go-Back-N**의 비효율성을 해결한 파이프라이닝 전송 방식
- **오류가 발생한 패킷만** 선택적으로 재전송
- 수신 측은 패킷을 버퍼에 저장 후 순서대로 정렬

---

## TCP 흐름 제어
송신 호스트가 수신 호스트의 처리 속도를 고려하여 송수신 속도를 균일하게 유지하는 기능
- **Stop-and-Wait ARQ**를 사용하게 되면 별도의 흐름 제어가 필요하지 않음
즉, 흐름 제어가 필요한 경우는 **파이프라이닝 전송 방식**
- **Go-Back-N ARQ**, **Selective Repeat ARQ**

### 슬라이딩 윈도우
- 윈도우 : 송신 호스트가 파이프라이닝할 수 있는 최대량
즉, 윈도우 크기만큼 확인 응답을 받지 않고도 한 번에 전송 가능하다는 의미

송신자는 수신자가 설정한 윈도우 크기(Window Size)만큼 연속적으로 패킷을 보냄
수신자는 수신한 패킷을 확인하고, 윈도우 크기를 업데이트하여 송신자에게 전송 속도를 조절하게 함

---

#### 혼잡(congestion)
많은 트래픽으로 인해 패킷의 처리 속도가 늦어지거나 유실될 우려가 있는 네트워크 상황

## TCP 혼잡 제어
- 송신 호스트가 혼잡한 정도에 맞춰 유동적으로 전송량을 조절하는 기능
- 흐름 제어의 주체가 **수신 호스트**라면 혼잡 제어의 주체는 **송신 호스트**

- 혼잡 윈도우 : 혼잡 없이 전송할 수 있는 데이터양
- 수신 윈도우는 수신 호스트가 헤더로 알려줌
- 혼잡 윈도우는 송신 호스트가 알아서 직접 계산해서 알아내야 함

## 혼잡 제어 알고리즘
### AIMD(Additive Increase/Multiplicative Decrease)방식
합으로 증가, 곱으로 감소
- 혼잡이 감지되지 않는다면, 혼잡 윈도우를 RTT마다 1씩 선형적으로 증가
- 혼잡이 감지되면, 혼잡 윈도우를 절반으로 떨어뜨림
위의 과정을 반복

### 느린 시작 알고리즘 (Slow Start)
- 혼잡 윈도우를 1부터 시작해 문제 없이 수신된 ACK 세그먼트 하나당 1씩 증가시키는 방식
- 혼잡 윈도우는 RTT마다 2배씩 지수적으로 증가 -> 초기 전송 속도 빠른 확보
- 혼잡 윈도우가 **Slow Start Threshold**에 도달하면 **혼잡 회피 알고리즘**으로 전환
- 만약, 패킷 손실이 발생하면, 혼잡 윈도우를 줄이고 다시 **Slow Start**를 시작

### 혼잡 회피 알고리즘
**Slow Start**가 끝난 후, 네트워크가 혼잡해지는 것을 방지하기 위해 느리게(혼잡 윈도우를 선형적으로) 증가시키는 방식
- RTT마다 혼잡 윈도우를 1MSS씩 선형적으로 증가
- 만약, 패킷 손실이 발생하면, 혼잡 윈도우를 줄이고 다시 **Slow Start**를 시작

### 빠른 재전송 알고리즘
패킷이 손실되었을 때, 타이머가 만료되기 전에 빠르게 재전송하는 기법
TCP는 중복된 ACK가 **3번 연속**으로 오면 패킷이 손실되었다고 판단하고 해당 패킷을 즉시 재전송함

### 빠른 회복 알고리즘
패킷 손실이 발생했지만 완전히 **Slow Start**로 돌아가지 않고 **혼잡 회피 알고리즘**에서 복구하는 기법
중복 ACK 3번을 받은 경우, 혼잡 윈도우를 줄인 후, 선형적으로 증가시키면서 전송 속도를 회복

즉, 중복된 ACK가 3번 연속받게 되면 **빠른 재전송 알고리즘**과 **빠른 회복 알고리즘**을 실행


# HTTP
## HTTP
HTTP는 클라이언트-서버구조로 되어있고, 서버가 클라이언트의 상태를 저장하지 않는 무상태 프로토콜(**stateless**)
또한, 요청을 주고받을 때만 연결을 유지하고 응답 이후 연결이 끊어지는 **비연결성**을 갖음

### HTTP 발전 단계
#### HTTP 0.9
초기모델인 HTTP 0.9는 GET메서드만 지원을 해주었고 HTTP 헤더조차 없었습니다.
#### HTTP 1.0
HTTP 1.0에서는 모든 메서드를 지원하고, 헤더도 추가되었습니다. 또한, 한번의 데이터 전송을 위해 연결과 해제를 해야하는 비효율적인 구조입니다.
#### HTTP 1.1
이를 해결하기 위해 HTTP 1.1에서는 **keep-alive**속성이 헤더에 추가되어 지속적인 연결이 가능해졌습니다. 그래서 여러번의 데이터 전송을 하더라도, 한번의 연결과 한번의 해제만 있으면 됩니다.
#### HTTP 2.0
HTTP 2.0에서는 이전버전의 HOL(Head Of Line Blocking)문제: 무거운 헤더로 인해 이후의 패킷이 영향을 받는 문제를 해결하기 위해 **멀티플렉싱**을 지원하여 단일 TCP연결에도 여러 요청과 응답을 받을 수 있게 되었습니다. 또한, **헤더압축**도 지원합니다.
#### HTTP 3.0
HTTP 2.0의 긴 왕복지연시간(RTT)을 해결하기 위해 TCP기반을 **UDP**기반으로 바꾸어 지연시간을 3-RTT에서 1-RTT로 줄였습니다.
